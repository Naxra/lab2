#№ Отчет по лабораторной работе №3
## по курсу "Логическое программирование"

## Решение задач методом поиска в пространстве состояний

## студент: Храпова Н.С.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В.     |              |               |
| Левинская М.А.    |              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Пространство состояний представляет собой набор ситуаций. Из каждого состояния возможно перейти в другое состояние путем каких-то действий. Поэтому удобно использовать такой метод, когда у нас есть два заданных состояния -- начальное и конечное, и число всевозможных состояний конечно. Если представить такое пространство как граф, где вершинами являются состояния, то путь от начальной вершины до конечной будет показывать набор состояний, являющийся решением задачи. В итоге, такие задачи сводятся к задаче поиска в графе. Основные стратегии решения такой задачи, которые я использовала в своей работе, -- поиск в глубину, поиск в ширину и поиск с итеративным погружением.

Для представление графа в программировании обычно используют матричное представление, где граф задается своей матрицей смежности. В Прологе граф описывается предикатами путем явного перечисления всех дуг в виде пар вершин. Задание графа при помощи дуг является более гибким, чем матрица смежности, поскольку дуги могут задаваться не только явным перечислением, но и при помощи правил, что позволяет нам описывать очень сложные и большие графы, для которых матричное представление нерационально и вообще не всегда возможно.

## Задание

8. Вдоль доски расположены лунки, в каждой из которых лежит красный, белый или синий шар. Одним ходом можно менять местами два любых шара. Добиться того, чтобы сначала шли все красные шары, все синие -- последними, а белые -- посередине. Решить задачу за наименьшее число ходов

## Принцип решения

Основной принцип решения задачи состоит в следующем: идем по списку, перебирая по 2 шара из списка, проверяем лежат ли эти шары в правильной последовательности, если нет, то меняем их местами. Я использовала 3 алгоритма поиска: поиск в глубину, поиск в ширину и поиск с итеративным погружением. Они отражены в предикатах search_dpth, search_bdth и search_id соответсвенно.

Рассмотрим часть, общую для всех трех алгоритмов. Предикат prolong нужен, чтобы продлить все пути в графе, предотвращая зацикливания.
```prolog
prolong([X|T],[Y,X|T]):-
    move(X,Y),
    \+ member(Y,[X|T]).
```
Предикат move отражает переход между состояниями в графе. Во втором правиле проходим по списку, представляющему одно состояние, меняем элементы, стоящие не на своем месте, что позволяет получить другое состояние. Предикат between генерирует все целые числа от 0 до Len, т.е. генерируем все числа от 0 до длины списка, затем проверяем, правильно ли стоят элементы с меньшим порядковым индексом относительно элементов с большим порядковым индексом, и меняем эти элементы.
```prolog
move([H|_],Res):-
    move(H,Res).

move(st(L),st(ResL)):-
    length(L,Len),
    Len1 is Len - 1,
    between(0,Len1,A),
    between(0,Len1,B),

    A @< B,
    check_correct(L,A,B),
    swap_elem(L,A,B,X),

    ResL = X.
```
В предикате check_correct получаем N-ый и M-ый элементы списка. За синим шаром не могут лежать красный или белый, за белым шаром не может лежать красный.
```prolog
check_correct(L,N,M):-
    getNthElem(L,X,N),
    getNthElem(L,Y,M),
    ((X == blue, Y == red);
    (X == blue, Y == white);
    (X == white, Y == red)),
    !.
```

## Выводы

Для различных задач подходят различные виды поиска, и выбор должен зависеть от цели. В условиях ограничения по памяти лучше использовать поиск в глубину, а с целью поиска кратчайшего пути -- поиск в ширину. Поиск с итеративным углублением хоть и избегает экспоненциальной сложности, но подходит только для самых простых задач. 