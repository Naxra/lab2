% Подключаем данные с mother и father
% father(отец, потомок) и mother(мать, потомок)
?- consult('fam.pl').

% Свекровь - это мать мужа.
% Проверяется, что Y это свекровь для X
svekrov(X, Y):-
	% Мать мужа
	mother(Y, Husb),
	% Проверяем, что есть общий потомок
	% То есть X это жена
	father(Husb, Potomok),
	mother(X, Potomok).
	
% Задание 4 - степень родства двух произвольных индивидуумов 

% Чтобы можно было делать перебор, нужно отделить простые проверки от сложных
% Поэтому введен предикат simple_relative(Rel, X, Y).
% Он же вызывается из relative

% Сами предикаты simple_relative
% Если указан один и тот же человек
% Так же проверяем, что он либо чей-то предок, либо потомок (то есть есть в БД)
simple_relative(sam, X, X):- (mother(X,_);father(X,_);mother(_,X);father(_,X)).
% Y - это мама X
simple_relative(mother, X, Y):-
	mother(Y, X).
% Y - это отец X
simple_relative(father, X, Y):-
	father(Y, X).
% Свекровь Y для X
simple_relative(svekrov, X, Y):- 
	svekrov(X, Y).
% Y бабушка X
simple_relative(grandmother, X, Y):-
	% Смотрим потомков
	mother(Y, Predok),
	% Один из потомков должен быть предком для X
	(father(Predok, X);mother(Predok, X)).
% Y дедушка X
simple_relative(grandfather, X, Y):-
	% Смотрим потомков
	father(Y, Predok),
	% Один из потомков должен быть предком для X
	(father(Predok, X);mother(Predok, X)).
% Y - это жена X
simple_relative(wife, X, Y):-
	% Проверяем, что у них есть общий ребенок
	mother(Y, Potomok),
	father(X, Potomok).
% Y - это муж X
simple_relative(husband, X, Y):-
	% Проверяем, что у них есть общий ребенок
	mother(X, Potomok),
	father(Y, Potomok).
% Y - это потомок X
simple_relative(potomok, X, Y):-
	mother(X, Y);father(X, Y).
% Y - это сын X
simple_relative(son, X, Y):-
	(mother(X, Y);father(X, Y)),
	% Так же проверяем, что это сын, другими словами есть дети (узнаем, что это мужчина)
	father(Y, _).
% Y - это дочь X
simple_relative(daughter, X, Y):-
	(mother(X, Y);father(X, Y)),
	% Так же проверяем, что это дочь, другими словами есть дети (узнаем, что это женщина)
	mother(Y, _).
% Y - это брат или сестра X от одного и того же прямого родственника, но не обязательно от двоих (например, от мамы)
simple_relative(sibling, X, Y):-
	(
		% Либо одна и та же мама
		(mother(Mam, X), mother(Mam, Y));
		% Либо один и тот же отец
		(father(Dad, X), father(Dad, Y))
	),
	% Разные люди
	not(X=Y).

% Теперь, решаем саму задачу relative
% Простые отношения
relative(Rel, X, Y):-
	% Просматриваем все возможные введенные простые отношения
	simple_relative(Rel,X,Y).
% Теперь более сложный вариант
% Это универсальный поиск пути от Y до X
% Есть какие-то родственные взаимотношения, которые по шагам связывают Y с X
% Например, Y это потомок X1, X1 это потомок X2, X2 это мама X3 и вот этот X3 является мамой X
% Если посмотреть по дереву, то Y это внук или внучка X2, а для X этот X2 является бабушкой
% Стоит учитывать, что перебор в дереве осуществляется для всех возможных путей
% Например, у двух братьев мать одна и та же, бабушка с дедушкой и так далее. Соответственно, и результатов может быть много
relative(Way, X, Y):-
	% Запускаем расширенный предикат для поиска
	relative(Way, [], [], X, Y, 0).
% В данном предикате добавлены Names, Path и DebugPrint
% Список Names (исходно пустой "[]") содержит всех встреченных людей (их имена), нужен для предотвращения зацикливания (чтобы не было повторений)
% Например, мать - сын - мать - сын (одни и те же) и так далее
% Список Path включает в себя собственно путь в обратном порядке и наполняется по ходу поиска
% Флаг DebugPrint - если 1, то в случае, если найден путь, так же распечатываются имена (чтобы легче было проверять цепочки кто кому кем приходится)
% Первое описание предиката для 6 параметров
% Это точка останова, так как достигли X из Y
relative(Way, RevNames, RevWay, X, X, DebugPrint):- 
	% Разворачиаем списки, так как они перевернуты
	reverse(SimpleWay, RevWay), 
	% Исключаем Y, как исходное (в самом начале добавляется, чтобы исключить лишние переборы)
	reverse([_|SimpleNames], RevNames),
	% Присваиваем путь
	Way = SimpleWay,
	% Если установлен DebugPrint, то распечатываем имена
	((DebugPrint=1,write(SimpleNames));not(DebugPrint=1)).
% Второе описание предиката для 6 параметров
% Здесь происходит расширенный перебор
relative(Way, Names, Path, X, Y, DebugPrint):-
	% Ограничиваем перебор только простыми утверждениями potomok, mother, father
	% так как все остальные строятся из них, а это лишь увеличивает перебор
	% Потомок включен только потому, что нужен отслеживать обратный путь
	(CurrRelative=potomok;CurrRelative=mother;CurrRelative=father),
	% Y и первый элемент из обратного пути должно что-то связывать
	simple_relative(CurrRelative, CurrName, Y),
	% Проверяем, что найденное имя не присутствует в списке
	% Тем самым предотвращаем зацикливание
	not(member(CurrName, Names)),
	% Добавляем Y при первом проходе,
	% чтобы через него не проходить еще раз
	% Но делаем это тогда, когда Y уже точно определен
	(
		(member(Y,Names), NamesInFirst=Names);
		(not(member(Y,Names)), NamesInFirst=[Y])
	),
	% Имя найденного человека и пройденные элементы заносим в список проверки для следующего хода
	NamesNext = [CurrName|NamesInFirst],
	% Найденное отношение и пройденные элементы заносим в список проверки для следующего хода
	% В данном списке, отношения находятся в обратном порядке
	PathNext = [CurrRelative|Path],
	% Собственно, запускаем проверку следующего отношения,
	% но уже для текущего элемента (ищем связь с CurrName, то есть двигаемся к X)
	relative(Way, NamesNext, PathNext, X, CurrName, DebugPrint).


% Тот же расширенный поиск, но с распечаткой имен DebugPrint = 1
relative_debug(Way, X, Y):-
	% Запускаем расширенный предикат для поиска
	relative(Way, [Y], [], X, Y, 1).

